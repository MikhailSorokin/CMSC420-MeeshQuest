package cmsc420.meeshquest.datastructures;

import java.awt.geom.Point2D;
import java.awt.geom.Rectangle2D;
import java.util.HashSet;

import cmsc420.geom.Circle2D;
import cmsc420.geom.Geometry2D;
import cmsc420.meeshquest.citymapobjects.City;
import cmsc420.meeshquest.citymapobjects.Line;
import cmsc420.meeshquest.citymapobjects.Point;
import cmsc420.meeshquest.exception.CityAlreadyMappedException;
import cmsc420.meeshquest.exception.CityOutOfBoundsException;
import cmsc420.meeshquest.exception.RoadOutOfBoundsException;

public class PMQuadtree {

	/** root of the PR Quadtree */
	protected Node root;

	/** bounds of the spatial map */
	protected Point2D.Float spatialOrigin;

	/** width of the spatial map */
	protected int spatialWidth;

	/** height of the spatial map */
	protected int spatialHeight;

	/** used to keep track of cities within the spatial map */
	protected HashSet<String> cityNames;


	/**
	 * Constructs an empty PR Quadtree.
	 */
	public PMQuadtree() {
		root = WhiteNode.instance;
		cityNames = new HashSet<String>();
		spatialOrigin = new Point2D.Float(0, 0);
	}

	/**
	 * Sets the width and height of the spatial map.
	 * 
	 * @param spatialWidth
	 *            width of the spatial map
	 * @param spatialHeight
	 *            height of the spatial map
	 */
	public void setRange(int spatialWidth, int spatialHeight) {
		this.spatialWidth = spatialWidth;
		this.spatialHeight = spatialHeight;
	}


	/**
	 * Gets the height of the spatial map
	 * 
	 * @return height of the spatial map
	 */
	public float getSpatialHeight() {
		return spatialHeight;
	}

	/**
	 * Gets the width of the spatial map
	 * 
	 * @return width of the spatial map
	 */
	public float getSpatialWidth() {
		return spatialWidth;
	}

	/**
	 * Gets the root node of the PR Quadtree.
	 * 
	 * @return root node of the PR Quadtree
	 */
	public Node getRoot() {
		return root;
	}

	/**
	 * Whether the PR Quadtree has zero or more elements.
	 * 
	 * @return <code>true</code> if the PR Quadtree has no non-empty nodes.
	 *         Otherwise returns <code>false</code>
	 */
	public boolean isEmpty() {
		return (root == WhiteNode.instance);
	}

	/**
	 * Inserts a city into the spatial map.
	 * 
	 * @param city
	 *            city to be added
	 * @throws CityAlreadyMappedException
	 *             city is already in the spatial map
	 * @throws CityOutOfBoundsException
	 *             city's location is outside the bounds of the spatial map
	 */
	public void add(City city) throws CityOutOfBoundsException {
		/* check bounds */
		int x = (int) city.getX();
		int y = (int) city.getY();
		if (x < spatialOrigin.x || x >= spatialWidth || y < spatialOrigin.y
				|| y >= spatialHeight) {
			/* city out of bounds */
			throw new CityOutOfBoundsException();
		}

		//TODO: Need to call this an isolatedCity
		/* insert city into PRQuadTree */
		cityNames.add(city.getName());
		
		root = root.add(new Point(city, "isolated"), spatialOrigin, spatialWidth, spatialHeight);
	}
	
	/**
	 * Inserts a city into the spatial map.
	 * 
	 * @param city
	 *            city to be added
	 * @throws CityAlreadyMappedException
	 *             city is already in the spatial map
	 * @throws CityOutOfBoundsException
	 *             city's location is outside the bounds of the spatial map
	 */
	public void add(City startCity, City endCity) throws RoadOutOfBoundsException {
		/* check bounds (with roads too!)*/
		int startX = (int) startCity.getX();
		int startY = (int) startCity.getY();
		int endX = (int) endCity.getX();
		int endY = (int) endCity.getY();

		//FIXED - Need a check to see if a point is already contained;
		Point start = new Point(startCity);
		Point end = new Point(endCity);
		Line road = new Line(startCity, endCity);
		Rectangle2D.Double spatialMapRect = new Rectangle2D.Double(spatialOrigin.getX(),
				spatialOrigin.getY(), (double)spatialWidth, (double)spatialHeight);
		
		if (spatialMapRect.intersectsLine(road.getLine())) {
			//See which points can be added and used
			if (startX >= spatialOrigin.x && startX <= spatialWidth && startY >= spatialOrigin.y 
					&& startY <= spatialHeight && !contains(startCity.getName())) {
				root = root.add(start, spatialOrigin, spatialWidth, spatialHeight);
				cityNames.add(startCity.getName());
			} 
			
			if (endX >= spatialOrigin.x && endX <= spatialWidth && endY >= spatialOrigin.y 
					&& endY <= spatialHeight && !contains(endCity.getName())) {
				root = root.add(end, spatialOrigin, spatialWidth, spatialHeight);
				cityNames.add(endCity.getName());
			}
			
			//Set the new line here
			root = root.add(road, spatialOrigin, spatialWidth, spatialHeight);
		
		}  else {
			throw new RoadOutOfBoundsException();
		}
	}
	/**
	 * Removes a given city from the spatial map.
	 * 
	 * @param city
	 *            city to be removed
	 * @throws CityNotMappedException
	 *             city is not in the spatial map
	 */
	public boolean remove(City city) {
		final boolean success = cityNames.contains(city.getName());
		if (success) {
			cityNames.remove(city.getName());
			root = root
					.remove(city, spatialOrigin, spatialWidth, spatialHeight);
		}
		return success;
	}

	/**
	 * Clears the PR Quadtree so it contains no non-empty nodes.
	 */
	public void clear() {
		root = WhiteNode.instance;
		cityNames.clear();
	}

	/**
	 * Returns if the PR Quadtree contains a city with the given name.
	 * 
	 * @return true if the city is in the spatial map. false otherwise.
	 */
	public boolean contains(String name) {
		return cityNames.contains(name);
	}
	/**
	 * Returns if any part of a circle lies within a given rectangular bounds
	 * according to the rules of the PR Quadtree.
	 * 
	 * @param circle
	 *            circular region to be checked
	 * @param rect
	 *            rectangular bounds the point is being checked against
	 * @return true if the point lies within the rectangular bounds, false
	 *         otherwise
	 */
	public boolean intersects(Circle2D circle, Rectangle2D rect) {
		final double radiusSquared = circle.getRadius() * circle.getRadius();

		/* translate coordinates, placing circle at origin */
		final Rectangle2D.Double r = new Rectangle2D.Double(rect.getX()
				- circle.getCenterX(), rect.getY() - circle.getCenterY(), rect
				.getWidth(), rect.getHeight());

		if (r.getMaxX() < 0) {
			/* rectangle to left of circle center */
			if (r.getMaxY() < 0) {
				/* rectangle in lower left corner */
				return ((r.getMaxX() * r.getMaxX() + r.getMaxY() * r.getMaxY()) < radiusSquared);
			} else if (r.getMinY() > 0) {
				/* rectangle in upper left corner */
				return ((r.getMaxX() * r.getMaxX() + r.getMinY() * r.getMinY()) < radiusSquared);
			} else {
				/* rectangle due west of circle */
				return (Math.abs(r.getMaxX()) < circle.getRadius());
			}
		} else if (r.getMinX() > 0) {
			/* rectangle to right of circle center */
			if (r.getMaxY() < 0) {
				/* rectangle in lower right corner */
				return ((r.getMinX() * r.getMinX() + r.getMaxY() * r.getMaxY()) < radiusSquared);
			} else if (r.getMinY() > 0) {
				/* rectangle in upper right corner */
				return ((r.getMinX() * r.getMinX() + r.getMinY() * r.getMinY()) <= radiusSquared);
			} else {
				/* rectangle due east of circle */
				return (r.getMinX() <= circle.getRadius());
			}
		} else {
			/* rectangle on circle vertical centerline */
			if (r.getMaxY() < 0) {
				/* rectangle due south of circle */
				return (Math.abs(r.getMaxY()) < circle.getRadius());
			} else if (r.getMinY() > 0) {
				/* rectangle due north of circle */
				return (r.getMinY() <= circle.getRadius());
			} else {
				/* rectangle contains circle center point */
				return true;
			}
		}
	}


	private double currDistance; 
	private City closestCity;    
	private City[] closestCities;
	
	public City findClosestPoint(int givenX, int givenY, boolean usingIsolatedCity) { 
		currDistance = Double.MAX_VALUE; 
		closestCity = null; 
		return findClosestPoint(givenX, givenY, root, usingIsolatedCity); 
	} 
	
	private City findClosestPoint(int givenX, int givenY, Node node, boolean usingIsolatedCity) { 
		if (node.getType() != Node.EMPTY) { 
			if (node.getType() == Node.INTERNAL) { 
				GreyNode greyNode = (GreyNode)node; 
				for (int i = 0; i < 4; i++) {
					findClosestPoint(givenX, givenY, greyNode.children[i], usingIsolatedCity); 
				}
			} else if (node.getType() == Node.LEAF) {  
				for (Geometry2D g : ((BlackNode) node).getAllList()) {
					if (g.getType() == Geometry2D.POINT
							&& (
								(!usingIsolatedCity && ((Point) g).isolatedString().compareTo("") == 0)
							|| (usingIsolatedCity && ((Point) g).isolatedString().compareTo("") != 0)
							)
						) {
						Point point = (Point)g;
						double distance = 
								Math.sqrt(Math.pow(point.getPoint().getX() - givenX,2) 
										+ Math.pow(point.getPoint().getY() - givenY,2)
										);
						if (distance < currDistance) { 
							closestCity = point.getCity(); 
							currDistance = distance; 
						} else if (distance == currDistance && closestCity != null) { 
							int value = closestCity.getName().compareTo
									(point.getCity().getName()); 
							if (value < 1) { 
								closestCity = point.getCity(); 
							} 
						} 
					}
				}
			} 
		} 
		return closestCity; 
	}
	
	public City[] findClosestRoad(int givenX, int givenY) { 
		Point2D.Double givenPoint = new Point2D.Double(givenX, givenY);
		currDistance = Double.MAX_VALUE;
		closestCities = new City[2]; 
		return findClosestRoad(givenPoint, root); 
	} 

	private City[] findClosestRoad(Point2D givenPoint, Node node) {
		if (node.getType() != Node.EMPTY) { 
			if (node.getType() == Node.INTERNAL) { 
				GreyNode greyNode = (GreyNode)node; 
				for (int i = 0; i < 4; i++) {
					findClosestRoad(givenPoint, greyNode.children[i]); 
				}
			} else if (node.getType() == Node.LEAF) {  
				for (Geometry2D g : ((BlackNode) node).getAllList()) {
					if (g.getType() == Geometry2D.SEGMENT) {
						Line line = (Line)g;
						double distance = line.getLine().ptLineDist(givenPoint);
						//System.out.println("Start: " + line.getStartCity().getName() + ", End: " + line.getEndCity().getName() + ", Distance: " + distance);
						
						if (distance < currDistance) { 
							if (line.getStartCity().getName().compareTo(line.getEndCity().getName()) < 0) {
								closestCities[0] = line.getStartCity(); 
								closestCities[1] = line.getEndCity(); 
							} else {
								closestCities[0] = line.getEndCity(); 
								closestCities[1] = line.getEndCity(); 
							}
							currDistance = distance; 
						} else if (distance == currDistance && closestCities[0] != null && closestCities[1] != null) { 
							int firstComparator = closestCities[0].getName().compareTo
									(line.getStartCity().getName()); 
							if (firstComparator == 0) { 
								int secondComparator = closestCities[1].getName().compareTo
										(line.getEndCity().getName()); 
								if (secondComparator < 0) {
									//Only when endCity is larger, 
									if (line.getStartCity().getName().compareTo(line.getEndCity().getName()) < 0) {
										closestCities[0] = line.getEndCity(); 
										closestCities[1] = line.getStartCity(); 
									} else {
										closestCities[0] = line.getStartCity(); 
										closestCities[1] = line.getEndCity(); 
									}
								}
							} else if (firstComparator < 0) {
								if (line.getStartCity().getName().compareTo(line.getEndCity().getName()) < 0) {
									closestCities[0] = line.getEndCity(); 
									closestCities[1] = line.getStartCity(); 
								} else {
									closestCities[0] = line.getStartCity(); 
									closestCities[1] = line.getEndCity(); 
								}
							}
						} 
					}
				}
			} 
		} 
		return closestCities; 
	} 
	
	public City findClosestRoad(City start, City end) { 
		Line road = new Line(start, end);
		currDistance = Double.MAX_VALUE; 
		closestCity = null; 
		return findClosestRoad(road, root); 
	} 

	private City findClosestRoad(Line road, Node node) {
		if (node.getType() != Node.EMPTY) { 
			if (node.getType() == Node.INTERNAL) { 
				GreyNode greyNode = (GreyNode)node; 
				for (int i = 0; i < 4; i++) {
					findClosestRoad(road, greyNode.children[i]); 
				}
			} else if (node.getType() == Node.LEAF) {  
				for (Geometry2D g : ((BlackNode) node).getAllList()) {
					//Might need to include points as well
					if (g.getType() == Geometry2D.POINT) {
						Point point = (Point)g;
						
						if (road.getStartCity().getName().compareTo(point.getCity().getName()) != 0
							&& road.getEndCity().getName().compareTo(point.getCity().getName()) != 0) {
							double distance = road.getLine().ptLineDist(point.getPoint());
							//System.out.println("Start: " + point.getCity().getName() + ", Distance: " + distance);
							
							if (distance < currDistance) { 
								closestCity = point.getCity(); 
								currDistance = distance; 
							} else if (distance == currDistance && closestCity != null) { 
								int value = closestCity.getName().compareTo
										(point.getCity().getName()); 
								if (value < 0) { 
									closestCity = point.getCity(); 
								} 
							} 
						}
					}
				}
			} 
		} 
		return closestCity; 
	} 
    
}
